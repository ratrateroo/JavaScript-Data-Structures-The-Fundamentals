Course Curriculum

Getting Started
 •Welcome to the Course! (1:11)
 •What are "Data Structures"? (4:58)
 •Course Resources
 •Arrays: Recap (8:57)
 •Sets: Recap (5:46)
 •Arrays vs Sets (1:34)
 •Objects: Recap (7:05)
 •Maps: Recap (7:37)
 •Objects vs Maps (1:43)
 •WeakSet and WeakMap (2:16)
 •Linked Lists (A First Custom Data Structures) (2:46)
 •Starting with Linked Lists and "append" (13:19)
 •Outputting the Linked List (4:58)
 •Prepend to Linked Lists (4:09)
 •Deleting Nodes (10:31)
 •"find" and "insertAfter" (6:56)
 •Linked Lists: Why and Time Complexity (5:28)
 •Linked Lists vs Arrays (7:06)
 •Module Resources

Lists & Tables
 •Module Introduction (0:55)
 •What are "Lists" and "Tables"? (4:22)
 •Built-in Lists and Tables (3:42)
 •Introducing "Stacks" (5:51)
 •Building a "Stack" Data Structure (7:01)
 •Considering a Linked List Stack (2:41)
 •Stacks with Linked Lists (9:12)
 •Stacks: Time Complexity (4:50)
 •Introducing Queues (3:24)
 •Building a Queue (4:34)
 •Linked Lists & Queues (5:09)
 •Queue Time Complexity (4:45)
 •Introducing Hash Tables (4:18)
 •Why we need Tables (9:54)
 •Building a Basic Hash Table (12:20)
 •Understanding Hash Collisions (4:58)
 •Solving Collisions with Chaining (11:51)
 •Solving Collisions with Open Addressing (10:42)
 •Hash Tables: Time Complexity (7:04)
 •Hash Tables: Summary (4:46)
 •Module Resources

Trees
 •Module Introduction (1:35)
 •What are "Trees"? (3:28)
 •Core Terminology (8:58)
 •An Example Tree (2:43)
 •A First Tree in Code (11:16)
 •A Better Filesystem Tree (14:10)
 •Removing Tree Nodes (7:06)
 •Describing Our Tree (6:49)
 •Trees: Time Complexity (4:42)
 •Depth-first vs Breadth-first Search (2:21)
 •Implementing Depth-first Search (6:01)
 •Implementing Breadth-first Search (3:27)
 •Depth-first Search vs Breadth-first Search (5:06)
 •Introducing Binary Search Trees (BST) (3:34)
 •Adding Values to BST (6:27)
 •Finding Values in BST (10:13)
 •Removing Leaf Nodes in BST (7:46)
 •Removing "One-Child" Nodes in BST (5:12)
 •Removing "Multi-Child" Nodes in BST (12:09)
 •BST Time Complexity (3:38)
 •Introducing AVL Trees (3:08)
 •Balancing Trees with Rotations (4:05)
 •Understanding Balance Factors (2:59)
 •Adding Depth and Balance Factors (6:25)
 •Finding the Right Rotation (8:07)
 •Implementing Left Rotation (9:50)
 •Implementing Right Rotation (3:21)
 •Implementing Left-Right Rotation (8:10)
 •Implementing Right-Left Rotation (3:28)
 •Testing the AVL Tree (3:06)
 •AVL vs BST (1:05)
 •Introducing Tries (3:35)
 •Building a Trie (12:01)
 •Finding Nodes in a Trie (3:24)
 •Deleting Keys (3:57)
 •Tries: Time Complexity and Comparison to Hash Tables (5:41)
 •Module Resources

Priority Queues & Heaps
 •Module Introduction (0:37)
 •Understanding Priority Queues (2:03)
 •Building a Regular Queue (4:22)
 •Priority Queues & Time Complexity (2:07)
 •Building a Basic Priority Queue (7:33)
 •Introducing Heaps (3:22)
 •Exploring the Heap Concept (5:50)
 •Building a Heap (11:20)
 •Processing Items (11:51)
 •A Heap-based Priority Queue (4:34)
 •Heaps & Time Complexity (5:53)
 •Module Resources

Graphs
 •Module Introduction (0:37)
 •Graphs: What and Why? (6:01)
 •Graphs with an Adjacency Matrix (9:56)
 •Using Adjacency Lists Instead (4:27)
 •Adjacency Lists vs Matrices (5:44)
 •Building a Graph Structure (7:06)
 •Adding Graph Methods (7:01)
 •Removing Nodes & Edges (10:47)
 •Using Sets in Graphs (7:14)
 •Summary (1:08)
 •Building a Social Network Graph (5:53)
 •Module Resources
 
Summary & Next Steps
 •Course Slides
 •Next Steps
